# class custom_range:
#     def __init__(self,start,stop,step):
#         self.start = start
#         self.stop = stop
#         self.step = step
    
#     def __iter__(self): ##generate iterator by callig iterator class
#         return range_iterator(self)  # Create an instance of range_iterator and return it

    

# class range_iterator:
#     def __init__(self, iterable_obj):
#         self.iterable = iterable_obj

#     def __iter__(self):
#         return self    # beacuse iter on iterator will give the itself or say same itertaor obj
#                        # Iterator's __iter__ method should return itself
    
#     def __next__(self):
#         if (self.iterable.step > 0 and self.iterable.start >= self.iterable.stop) or (self.iterable.step < 0 and self.iterable.start <= self.iterable.stop):
#             raise StopIteration

#         current = self.iterable.start
#         self.iterable.start += self.iterable.step
#         return current

# for i in custom_range(1,10,2):
#     print("pos",i)

# for i in custom_range(10,21,-1):
#     print("negative",i)



class CustomRange:
    def __init__(self, start, end, step=1):
        self.start = start
        self.end = end
        self.step = step
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if (self.step > 0 and self.current >= self.end) or (self.step < 0 and self.current <= self.end):
            raise StopIteration
        else:
            current_value = self.current
            self.current += self.step
            return current_value

# Example usage:
for i in CustomRange(10, -1, -1):
    print(i)

