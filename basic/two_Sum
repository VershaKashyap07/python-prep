arr =[2,6,5,8,3]
target =11
n =len(arr)
def brute_force(arr,target,n):
    for i in range(n-1):
        for j in range(i+1,n):
            if arr[i]+arr[j]==target:
                return [i,j]
    
print("brute_force",brute_force(arr,target,n))

def check(arr,target):
    for i in range(len(arr)-1):
        diff = target - arr[i]
        for j in range(i+1, len(arr)):
            if arr[j]==diff:
                return [i,j]
    return[-1,-1]

print("check",check(arr,target))

arr1 = arr.copy()


def optimal(arr,target,n):
    left=0
    right =n-1
    arr.sort()
    while left<right:
        if arr[left]+arr[right]==target:
            return [arr1.index(arr[left]),arr1.index(arr[right])]
        elif arr[left]+arr[right]> target:
            right-=1
        elif arr[left]+arr[right]<target:
            left+=1
    return(-1,-1)
print("sort",optimal(arr,target,n))


'''Time Complexity: O(N) + O(N*logN), where N = size of the array.
Reason: The loop will run at most N times. And sorting the array will take N*logN time complexity.

Space Complexity: O(1) as we are not using any extra space.

Note: Here we are distorting the given array. So, if we need to consider this change, the space complexity will be O(N).'''

def optimal(arr,target):
    prevMap = {}
    for i , n in enumerate(arr):
        diff = target - n
        if diff in prevMap:
            return [prevMap[diff],i]
        prevMap[n] = i
    return [-1,-1]

print(optimal(arr,target))



